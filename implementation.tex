\section{Implementation}

Odyssey is implemented in two pieces:
  a ``backend'' that uses Herbie to dispatch numerical tasks,
  and a ``frontend'' implemented using web technologies
  to present an interactive workbench UI to the user.
Odyssey can be used via a web browser
  or embedded into tools like
  Visual Studio Code.

\subsection{``Database Workbench'' Architecture}

The key to supporting our design principles
  is Odyssey's ``database workbench'' architecture.
In this architecture,
  Odyssey stores a list of rewritings that the user
  is exploring and makes calls to independent analysis, visualization, 
  and generation tools that run on the backend.
This architecture stores all of the state on the frontend,
  allowing direct manipulation by the user.
The automated analysis, visualization, and generation tools,
  meanwhile, are stateless,
  being invoked by Odyssey on whatever rewritings
  the user is currently considering.
This architecture puts the user at the center at the center of the search.

This architecture also leads to a natural separation of concerns
  between the frontend and backend.
The Odyssey frontend implements all interactions,
  graphics, and manipulation actions.
However, all numerical tasks
  (sampling, evaluating error, and generating expressions)
  are the responsibility of the backend.
This 
  % is particularly important to Odyssey,
  % because TypeScript, which the frontend is written in,
  % does not provide 
  ensures proper support for 
  low-level operations
  like enumerating floating-point numbers
  and other numerical tasks that
  depend on the user's target environment.
  % and the TypeScript environment's implementations
  % of functions like \texttt{log} and \texttt{sqrt}
  % may differ from the user's target environment.
While Odyssey currently only invokes Herbie subsystems,
  the backend is intended to invoke other tools as well.
% Here, the backend would be tasked with ensuring
%   that all of the tools invoked by the user interoperate,
%   a responsibility that currently falls to the user.
  
\subsection{The Odyssey Frontend}

The Odyssey frontend provides a rewritings table and error plot
  to help users diagnose problems, generate solutions, and tune the results.

The main state is stored in the rewritings table,
  shown in \Cref{fig:generation}.
All rewritings the user is considering---%
  including both those generated by Herbie
  and those entered by the user,
  are stored here.
Each rewriting also shows its average error,
  for easy comparison.
A checkbox allows the user to hide expressions
  from the error plot and other parts of the UI,
  which functions as a kind of ``archiving'' operation
  so that users can ignore sub-par rewritings
  without an irreversible deletion operation.
Additionally, a clipboard button
  allows users to copy rewritings,
  which is essential to users modifying or combining rewritings.
None of these interactions involve the backend,
  and are thus instantly responsive to user action.

The input box allows adding rewritings to the table
  using a natural mathematical syntax
  backed by a parser from the mathjs library~\cite{mathjs}.
Odyssey then converts that input
  both to an instantly-updating LaTeX render
  (to help users catch mistakes and typos)
  and to the standard FPCore input format,
  which Herbie uses to represent rewritings.
Herbie is then invoked to analyze the error of the new rewriting,
  which is then added to the plot.
Additionally, rewritings can be added to the table
  by invoking Herbie to generate suggested rewritings;
  any rewritings suggested by Herbie are also
  converted from FPCore back to LaTeX and mathematical syntax
  so that the user does not have to understand FPCore
  in order to use Odyssey.

The main visualization is a large error plot.
This plot shows the error on all of the sampled inputs,
  for each of the rewritings in the rewritings table,
  with colors helping users match each rewriting to its error plot.
Because rewritings often have identical error over some range
  the user can click on a rewriting in the table
  to highlight it in the error plot;
  users can also use checkboxes in the table
  to hide expressions from the error plot.
By hovering over each point in the error plot,
  the user can see the exact sampled input,
  and by clicking on a point,
  they can update parts of the UI
  (such as the local error heatmap)
  to focus on that specific input.
The user can also adjust the input domain
  using an input range selector below the plot.
Changing the input domain causes Odyssey
  to resample inputs, evaluate each rewriting on the new inputs,
  and redraw the error plot using the newly-evaluated errors.
Once again, besides adjusting the input range,
  all operations are instantaneous and do not invoke the backend.

On its own, Odyssey does not provide any additional features.
However, Odyssey is extensible,
  and tools invoked by the backend
  can offer additional visualizations.
To see these additional visualizations,
  the user selects a specific rewrite,
  and the visualizations are shown beneath the main UI.
Selecting the specific rewriting
  means that different rewritings,
  which might come from different sources,
  can provide different kinds of justifications or explanations.
Our Herbie backend provides two such visualizations:
  the local error heatmap and derivations.
When Odyssey is extended to support additional backend tools,
  we expect each tool to provide its own additional visualizations.
% In lieu of additional visualizations,
%   manually-entered expressions can have a ``note''
%   explaining the user's reasoning
%   or referencing some external source.

\subsection{The Herbie Backend}

Odyssey's Herbie backend is used
  to sample inputs, evaluate the error of rewritings,
  and suggest new rewritings to the user.
Herbie was originally designed as a batch-mode tool,
  so part of our work involved adding an HTTP API 
  to expose various internal analysis functions
  so that they can be invoked by Odyssey.
Luckily, the Herbie features that we wanted to expose,
  including input sampling and error evaluation,
  were already independently-invocable functions in Herbie.
% Odyssey therefore does not require many changes to Herbie's internals,
%   and tools besides Herbie could potentially be used in the backend.

A key challenge in the backend is dealing with latency.
Herbie's initial design as a batch-mode tool 
  means that Herbie typically
  samples inputs, evaluates error, and suggests rewritings
  every time it is invoked,
  even though some of those steps (like sampling inputs) are slow
  while others (like evaluating error) are fast.
To address this, Odyssey's Herbie backend
  independently caches the outputs of each step (like the sampled inputs).
This way, evaluating the error of an expression
  is done on cached sampled inputs and takes milliseconds
  instead of resampling the inputs, which would take seconds.
% Herbie operations typically take several seconds,
%   and suggesting alternatives for complex expressions
%   can take minutes.

Further, all of Odyssey's invocations of the backend are asynchronous,
  allowing the user to continue working
  while Herbie processes their requests.
% Because Odyssey's core interactions
%   (such as selecting individual rewritings and examining input points)
%   do not require interaction with the backend,
%   Herbie's latency is hidden to a significant extent.

% This approach was also used when extending Odyssey
%   with two additional visualizations from Herbie:
%   the local error heatmap and derivations.
% The local error heatmap uses the cached sampled inputs
%   to evaluate an internal Herbie heuristic, local error,
%   which estimates the error introduced
%   at each input and by each operation in some rewriting.
% Odyssey then visualizes the results
%   by coloring the high-error operations of the rewriting in red.
% While local error was originally just an internal Herbie heuristic,
%   users found it helpful in diagnosing floating-point problems.
% Additionally, derivations use
%   the cached suggested rewritings produced by Herbie
%   to show the sequence of steps Herbie took to produce its output.
% Originally meant as a debugging tool for the Herbie developers,
%   we found that derivations increased user trust in Herbie's results.
% Importantly, while local error and derivations are specific to Herbie,
%   the general principle of exposing internal heuristics
%   could be applied to other tools.

By keeping the latency of most operations under a second
  and offering access to previously-inaccessible heuristics 
  like local error (an internal search heuristic) 
  and expression derivations (previously a debugging tool for Herbie developers),
  Odyssey's ``database workbench'' architecture
  allows users to stay in the flow of their work as they solve rewriting problems.

  % access to useful (and previously-inaccessible) search heuristics.
  % then provides a modular set of additional visualizations
  % where these tools' internal heuristics can be presented to the user.
